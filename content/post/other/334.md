---
title: "Kotlin使ってみて感じる便利さと葛藤"
slug: 334
date: 2016-05-03
lastmod: 2016-05-03
tags: 
    - Kotlin
---

<div id="wppda_alert">この記事は最終更新から3ヶ月以上が経過しています。情報が古い可能性があります。</div><p>最近アプリやAndroid Studio用プラグインを作るのにKotlinを使っています。</p>
<p>始めたばかりの頃は「Javaだとああ書くんだけど、Kotlinだとどう書けばいいんだ」ということが多かったです。Javaでまともに書けないのにKotlinに手を出すのは早いんじゃないかとも思っていました。</p>
<p>しかし少しずつ試していくと、Kotlinの便利な部分が分かってきてきました。</p>
<p>私の場合、「Kotlinで書き始めたんだけどやっぱ使い方よくわからないからJavaに戻そう」とう場面が初期の頃はよくありました。はじめはKotlinで書いていたけど、やっぱりJavaで実装しようとという感じです。</p>
<p>そんなときに、「Javaに戻すのめんどくせえ」と感じる部分があって、そこで改めて「Kotlinってやっぱ便利やなぁ」なんて実感しました。</p>
<p>それからというもの、Kotlinの比重が徐々に増えてきて、今では逆にJavaで書く方が面倒くさいと感じるようになってしまいました。</p>
<p>一方で、Kotlinが無敵というわけではありません。Annotation Processingを使うライブラリがKotlinだとうまく使えないことがあったり（基本的には大丈夫ですが、Javaで書けば動くコードがKotlinで同じように書くと動かないことがあったりします）、Javaと比べるとコード補完が遅かったり、Kotlinを使うことで感じるストレスもあります。</p>
<p>ですが、不便さを差し置いてもKotlinで書いた方がすっきり書けるのはやっぱり快適だと思っています。</p>
<h2>テストコードから始めるといいかも</h2>
<p>どなたかの記事で、Kotlinはテストコードから導入してみたらどうかという記事を読みました。私もいい方法だと思います。Kotlinの便利さを実感するためではなく、どう書くかを知るのにちょうどいいと思います。</p>
<p>私もJUnitでのユニットテストをKotlinで書いています。テスト対象をKotlinで書いてるからとか、セミコロンつけなくてもいいから、とかそんな理由です。ユニットテストについてはKotlinが便利だからという理由はあまりないかもしれません。</p>
<p>ユニットテストにおいてKotlinが便利だと思うのは、バッククオート(`)で囲むことで、メソッド名やクラス名を数字から始めることができたり、途中に空白を含めることができたりすることでしょうか。</p>
<p>私はテスト名に日本語を使うことが多いです。そしてそのときに、メソッド名に使える文字に制約があるのが微妙に困ります。</p>
<p>例えば各月の最終日を求めるメソッドのテストをするのに「4月の場合は30日を返す」というテスト名にしたくてもできません。Javaではメソッド名を数字から始めることができないからです。だからこんなときは「月に4月を指定したら30日を返す」という感じのメソッド名にするのですが、これが微妙なストレスになります。（頭に「月を」つけるだけやんという感じですが、微妙にストレス感じるんですよこれ）</p>
<p>Kotlinではこの制約に煩わされることがありません。メソッド名をバッククオートで囲めば、数字から始めようが、途中に空白を挟もうが問題ないのです。</p>
<pre><code>    @Test fun `2つの時刻の差を求める`(){
        val time1 = LocalDateTime.of(2014, 1, 1, 23, 58, 30)
        val time2 = LocalDateTime.of(2014, 1, 2,  0,  4, 30)
        val actual = Duration.between(time1,time2).seconds
        assertThat(actual, `is`(360L))
    }
</code></pre>
<p>なにそれ気持ち悪いと思われるかもしれませんが、これはれっきとしたKotlinの仕様です。</p>
<p><a href="https://kotlinlang.org/docs/reference/grammar.html#SimpleName">Grammar &#8211; SimpleName</a></p>
<p>Javaのメソッド名規約によってテストメソッド名を考えるのが面倒くさいなぁと感じている人は私だけではないと思いたい。</p>
<p>一方でKotlinでユニットテスト書けば便利なことばかりではありません。例えば<code>assertThat</code>などを使おうとするとimport文を手書きで書かないと認識してくれないのが不便です。（私の環境の問題なのかもしれません。JavaだとALT+Enterでimportできるんですけどね・・・）</p>
<h2>セミコロンつけなくてもいい</h2>
<p>単純なことですが、Kotlinは文末にセミコロンをつけなくてもいいのです。</p>
<p>これが便利・・・と言いたいところですが、私は半々かなぁと感じています。</p>
<p>確かにいちいちセミコロンつけなくてもいいので楽です。たまにJavaでコードを書くときに、しょっちゅうセミコロンつけ忘れます。それくらいには快適です。</p>
<p>一方セミコロンが不要なせいで、メソッドチェーンするときに私は微妙にストレスを感じます。</p>
<p>Javaだとメソッドチェーンするときに改行をするとインデントを一段深くしてくれます。</p>
<p>しかしKotlinでは改行した時に文末なのか次の文に移るのかが判別不能なので、インデントを深くしてくれたりしません。これが毎回微妙にめんどうくさいです。私はいつもドットを打ってカーソル戻して改行するという方法をとって回避しています。</p>
<p>多分Reformat Code（<code>Cmd+Alt+l</code>）を使うのが楽なんでしょうけども。みんなどうしてるんだろう・・・。</p>
<h2>文字列の扱いが便利</h2>
<p><a href="https://kotlinlang.org/docs/reference/basic-types.html#strings">Strings</a></p>
<p>Javaだと文字列に変数を埋め込もうと思うと、+演算子で連結しなければなりません。もしくは<code>String.format()</code>を使うかですね。</p>
<p>Kotlinだとそんな面倒くさいことをせずとも、文字列中に変数を埋め込めるので便利です。こんな感じに書けるわけです。</p>
<p><code>val hoge = "num is $num"</code></p>
<p>埋め込む変数が多くなればなるほど、これはとても便利になります。デバッグのために変数の中身を文字列として出力して確認することがよくあると思いますが、そんなときに特に楽だと思います。</p>
<p>複数行に渡る文字列も、<code>"""</code>で囲むことでそのまま文字列として扱うことができます。ただしこれを使うと、インデントによる空白も文字列に含まれてしまうので、使いドコロが難しい気もします。</p>
<h2>配列操作が便利</h2>
<p>例えば配列の要素の中から最大値を取得しようと思ったら、Javaだとこんな感じになるでしょう。</p>
<pre><code>int[] array = {1,20,3,40,5,16,7};
int max = 0;
for (int num : array) {
    max = Math.max(num, max);
}
</code></pre>
<p>Kotlinだとこうです。</p>
<pre><code>val array = arrayOf(1,20,3,40,5,16,7)
val max = array.max()
</code></pre>
<p>わざわざループを回したりしなくてすんで、非常にすっきりします。</p>
<p>他にも、例えば配列のインデックスもあわせて使いたい場合は、<code>.forEachIndexed{index, data -&gt;//処理}</code>なんて書けます。for文を書く頻度がだいぶ少なくなります。</p>
<p>一方で、配列の宣言がいまだに慣れません。</p>
<p><code>arrayOf()</code>、<code>arrayListOf()</code>、<code>listOf()</code>、<code>mutableListOf()</code>などなど、いろいろ種類があっていつも混乱します。JavaのListを引数に取るメソッドをKotlinから利用するときなど、引数の型が違うという感じでAndroid Studioに怒られるのがしょっちゅうです。</p>
<h2>拡張関数が便利</h2>
<p>Kotlinの便利さを実感するのがこの拡張関数です。</p>
<p>例えばorg.threeten.bp.LocalDateTimeとjava.sql.Timestampの変換をしようと思うと、DateTimeUtilsクラスを利用すればできます。</p>
<pre><code>val localDateTime = LocalDateTime.now()
val timestamp = DateTimeUtils.toSqlTimestamp(localDateTime)
</code></pre>
<p>でもこれ、LocalDateTimeクラスに直接Timestampへの変換を行うメソッドがあったらもっとスマートに書けます。そしてKotlinなら拡張関数を利用することでそれが実現できます。</p>
<p>例えばUtil.ktというファイルを作成して、そこにこんな関数を定義します。</p>
<pre><code>fun LocalDateTime.toTimestamp() = DateTimeUtils.toSqlTimestamp(this)
</code></pre>
<p>すると<code>val timestamp = localDateTime.toTimestamp()</code>と書けるようになるのです。</p>
<p>Javaだとユーティリティクラスを作成して、staticメソッドでやっていたようなことを、Kotlinだとずっとスマートに実装することができます。これに手を出し始めるとJavaには戻れないですね。</p>
<p>ただ多用すると知らない人からみたら「なんぞこれ」というコードになってしまいそうです。自分で作って自分で使う分には便利で気持ちいいのですが、チームで使うときにはまた違う感想になるのかもしれません。</p>
<h2>まとめ</h2>
<p>私自身はKotlin便利で、全部Kotlinで書けたら楽だなぁとは思っているんですが、一方で素直にJavaで書いた方が楽じゃないかと思うときも良くあります。</p>
<p>書き上がったソースコードはすっきりしているものの、書いてる最中はコード補完が遅くてストレス感じます。単純に私のマシンスペックの問題なのかもしれませんが（3年前に買ったMacbook Airなのでいい加減買い換えたい）、固まってイライラすることも少なく無いです。たまにJavaで書くとコード補完が早くて快適に感じます。</p>
<p>KotlinはJavaと100％互換で、基本的にはKotlinかJavaかを意識しなくてもいいのですが、それでもやっぱりJavaとの境界は意識せざるを得ません。Javaのことを意識して書かざるをえないのであれば、はじめからJavaで書いた方が楽という部分はあると思います。</p>
<p>また、Android StudioのInstant Runとの関係かもしれませんが、変更したソースコードが反映されずにデバッグに余計な手間がかかることがたまにあるのもストレスです。毎回起こるわけでもないのがまた微妙なところです。</p>
<p>素直にJavaで実装したほうが楽なのかもしれないけれども、一方でKotlinの便利さを知ってしまったがゆえにJavaで書くのも面倒くさいという葛藤を抱いております。ちょっと前までは「フルKotlinが一番便利でいい」とこだわろうとしていたのですが、今はKotlinとJavaをいい感じに併用していく柔軟性が大事なのかなと考えを改めているところです。</p>

  